


func check_axis(origin, direction float64) (float64, float64) {
	// Convert zero numerators to small, appropriately signed value to avoid a
	// NaN result below if denominator is zero.
	tmin_numerator := -1 - origin
	if tmin_numerator == 0 {
		tmin_numerator = -math.SmallestNonzeroFloat64
	}
	tmax_numerator := 1 - origin
	if tmax_numerator == 0 {
		tmax_numerator = math.SmallestNonzeroFloat64
	}

	// Capture the sign of direction (and handle -0.0).
	// See http://www.cs.utah.edu/~awilliam/box/box.pdf improved method (end pp2)
	// We're relying on IEEE fp rules to produce +Inf, -Inf if appropriate.
	div := 1 / direction
	if div >= 0 {
		return tmin_numerator * div, tmax_numerator * div
	}
	return tmax_numerator * div, tmin_numerator * div    // swap
}



var left: [Shape] = []
        var right: [Shape] = []

        let (boundsLeft, boundsRight) = boundingBox().splitBoundingBox()

        for child in children {
            if boundsLeft.containsBox(box: child.parentSpaceBounds()) {
                child.removeFromParent()
                left.append(child)
            } else if (boundsRight.containsBox(box: child.parentSpaceBounds())) {
                child.removeFromParent()
                right.append(child)
            }
        }

        return (left, right)



Scenario: shade_hit() with a reflective, transparent material
  Given w ← default_world()
    And r ← ray(point(0, 0, -3), vector(0, -√2/2, √2/2))
    And floor ← plane() with:
      | transform                 | translation(0, -1, 0) |
      | material.reflective       | 0.5                   |
      | material.transparency     | 0.5                   |
      | material.refractive_index | 1.5                   |
    And floor is added to w
    And ball ← sphere() with:
      | material.color     | (1, 0, 0)                  |
      | material.ambient   | 0.5                        |
      | transform          | translation(0, -3.5, -0.5) |
    And ball is added to w
    And xs ← intersections(√2:floor)
  When comps ← prepare_computations(xs[0], r, xs)
    And color ← shade_hit(w, comps, 5)
  Then color = color(0.93391, 0.69643, 0.69243)



public double Schlick
    {
      get
      {
        double result;
        double cos;

        // find the cosine of the angle between the eye and normal vectors
        cos = Tuple.Dot(_eyev, _normalv);

        // total internal reflection can only occur if n 1> n2
        if (_n1 > _n2)
        {
          double n;
          double sin2t;

          n = _n1 / _n2;
          sin2t = Math.Pow(n, 2) * (1 - Math.Pow(cos, 2));

          if (sin2t > 1)
          {
            result = 1;
          }
          else
          {
            cos = Math.Sqrt(1 - sin2t);

            result = 0;
          }
        }
        else
        {
          result = 0;
        }

        if (result != 1)
        {
          double r0;

          r0 = Math.Pow((_n1 - _n2) / (_n1 + _n2), 2);

          result = r0 + (1 - r0) * Math.Pow(1 - cos, 5);
        }

        return result;
      }
    }

    public static Computation Prepare(Intersection hit, Ray ray, Intersection[] xs)
    {
      double t;
      Tuple point;
      Tuple eyev;
      Tuple normalv;
      Shape shape;
      bool inside;
      Tuple overpoint;
      Tuple reflectv;
      double n1;
      double n2;
      Tuple underPoint;

      t = hit.T;
      point = ray.Position(t);
      eyev = -ray.Direction;
      shape = hit.Object;
      normalv = shape.NormalAt(hit, point);

      if (Tuple.Dot(normalv, eyev) < 0)
      {
        inside = true;
        normalv = -normalv;
      }
      else
      {
        inside = false;
      }

      overpoint = point + normalv * Extensions.Epsilon;
      underPoint = point - normalv * Extensions.Epsilon;
      reflectv = Tuple.Reflect(ray.Direction, normalv);

      n1 = 1;
      n2 = 1;

      if (xs.Length != 0)
      {
        Computation.CalculateN(hit, xs, ref n1, ref n2);
      }

      return new Computation(t, shape, point, eyev, normalv, inside, overpoint, reflectv, n1, n2, underPoint);
    }

    public Color ColorAt(Ray ray, int remaining)
    {
      Color result;
      Intersection[] xs;
      Intersection hit;

      xs = this.Intersects(ray);
      hit = Intersection.Hit(xs);

      if (!hit.IsEmpty)
      {
        Computation comps;

        comps = Computation.Prepare(hit, ray, xs);

        result = this.ShadeHit(comps, remaining);
      }
      else
      {
        result = Color.Black;
      }

      return result;
    }

    public Color GetReflectedColor(Computation comps, int remaining)
    {
      Color result;

      if (remaining != 0)
      {
        double reflective;

        reflective = comps.Object.GetMaterial().Reflective;

        if (reflective == 0)
        {
          result = Color.Black;
        }
        else
        {
          Ray reflect;

          reflect = Ray.Create(comps.OverPoint, comps.Reflectv);

          result = this.ColorAt(reflect, remaining - 1) * reflective;
        }
      }
      else
      {
        result = Color.Black;
        ;
      }

      return result;
    }

    public Color GetRefractedColor(Computation comps, int remaining)
    {
      Color result;

      if (comps.Object.GetMaterial().Transparency == 0 || remaining == 0)
      {
        result = Color.Black;
      }
      else
      {
        double nRatio;
        double cosi;
        double sin2t;

        // find the ratio of the first index of refraction to the second
        // (this is inverted from the definition of Snell's Law)
        nRatio = comps.N1 / comps.N2;

        // cos(theta_i) is the same as the dot product of the two vectors
        cosi = Tuple.Dot(comps.Eyev, comps.Normalv);

        // find sin(theta_t)^2 via trigonometric identity
        sin2t = Math.Pow(nRatio, 2) * (1 - Math.Pow(cosi, 2));

        if (sin2t <= 1)
        {
          double cost;
          Tuple direction;
          Ray refractRay;

          // fnid the cos(theta_t) via trigonometric identity
          cost = Math.Sqrt(1 - sin2t);

          // compute the direction of the refracted ray
          direction = comps.Normalv * (nRatio * cosi - cost) - comps.Eyev * nRatio;
          refractRay = Ray.Create(comps.UnderPoint, direction);

          // find the color of the refacted ray, making sure to multiply
          // by the transparency value to account for any opacity
          result = this.ColorAt(refractRay, remaining - 1) * comps.Object.GetMaterial().Transparency;
        }
        else
        {
          result = Color.Black;
        }
      }

      return result;
    }